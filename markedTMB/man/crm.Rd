% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crm.R
\name{crm}
\alias{crm}
\title{Capture-recapture model fitting function}
\usage{
crm(
  data,
  ddl = NULL,
  begin.time = 1,
  model = "MSCJS",
  title = "",
  model.parameters = list(),
  design.parameters = list(),
  initial = NULL,
  groups = NULL,
  time.intervals = NULL,
  debug = FALSE,
  method = "nlminb",
  hessian = FALSE,
  accumulate = TRUE,
  chunk_size = 1e+07,
  control = list(),
  refit = 1,
  itnmax = 5000,
  scale = NULL,
  run = TRUE,
  compile = FALSE,
  extra.args = NULL,
  strata.labels = NULL,
  clean = FALSE,
  save.matrices = FALSE,
  savef = TRUE,
  getreals = FALSE,
  real.ids = NULL,
  check = FALSE,
  useHess = FALSE,
  optimize = TRUE,
  vcv = FALSE,
  unit_scale = TRUE,
  ...
)
}
\arguments{
\item{data}{Either the raw data which is a dataframe with at least one
column named ch (a character field containing the capture history) or a
processed dataframe}

\item{ddl}{Design data list which contains a list element for each parameter
type; if NULL it is created}

\item{begin.time}{Time of first capture(release) occasion}

\item{model}{Type of c-r model (eg, "cjs", "js")}

\item{title}{Optional title; not used at present}

\item{model.parameters}{List of model parameter specifications}

\item{design.parameters}{Specification of any grouping variables for design
data for each parameter}

\item{initial}{Optional vector of initial values for beta parameters; if
named from previous analysis only relevant values are used}

\item{groups}{Vector of names factor variables for creating groups}

\item{time.intervals}{Intervals of time between the capture occasions}

\item{debug}{if TRUE, shows optimization output}

\item{method}{optimization method}

\item{hessian}{if TRUE, computes v-c matrix using hessian}

\item{accumulate}{if TRUE, like capture-histories are accumulated to reduce
computation}

\item{chunk_size}{specifies amount of memory to use in accumulating capture
histories and design matrices; amount used is 8*chunk_size/1e6 MB (default
80MB)}

\item{control}{control string for optimization functions}

\item{refit}{non-zero entry to refit}

\item{itnmax}{maximum number of iterations for optimization}

\item{scale}{vector of scale values for parameters}

\item{run}{if TRUE, it runs model; otherwise if FALSE can be used to test model build components}

\item{compile}{if TRUE forces re-compilation of tpl file}

\item{extra.args}{optional character string that is passed to admb if use.admb==TRUE}

\item{strata.labels}{labels for strata used in capture history; they are converted to numeric in the order listed. Only needed to specify unobserved strata. For any unobserved strata p=0..}

\item{clean}{if TRUE, deletes the tpl and executable files for amdb if use.admb=T}

\item{save.matrices}{for HMM models this option controls whether the gamma,dmat and delta matrices are saved in the model object}

\item{savef}{if TRUE, save the makeAdFun result from TMB to report real values and matrices}

\item{getreals}{if TRUE, compute real values and std errors for TMB models; may want to set as FALSE until model selection is complete}

\item{real.ids}{vector of id values for which real parameters should be output with std error information for TMB models; if NULL all ids used}

\item{check}{if TRUE values of gamma, dmat and delta are checked to make sure the values are valid with initial parameter values.}

\item{useHess}{if TRUE, the TMB hessian function is used for optimization; using hessian is typically slower with many parameters but can result in a better solution}

\item{optimize}{if TRUE, optimizes to get parameter estimates; set to FALSE to extract estimates of ADREPORTed values only}

\item{vcv}{if TRUE, computes var-covariance matrix of ADREPORTed values}

\item{unit_scale}{default TRUE, if FALSE any time scaled parameter (e.g. Phi,S) is scaled when computing real value such that it represents the length of the interval rather than a unit interval}

\item{...}{optional arguments passed to js or cjs and optimx}
}
\value{
crm model object with class=("crm",submodel)
}
\description{
Fits user specified models to some types of capture-recapture wholly in R
and not with MARK.  A single function that processes data, creates the
design data, makes the crm model and runs it
}
\details{
This function is operationally similar to the function \code{mark in RMark}
in that is is a shell that calls several other functions to perform the
following steps: 1) \code{\link{process.data}} to setup data and parameters
and package them into a list (processed data),2)
\code{\link{make.design.data}} to create the design data for each parameter
in the specified model, 3) \code{\link{create.dm}} to create the design
matrices for each parameter based on the formula provided for each
parameter, 4) call to the specific function for model fitting. As with \code{mark} the calling
arguments for \code{crm} are a compilation of the calling arguments for each
of the functions it calls (with some arguments renamed to avoid conflicts).
expects to find a value for \code{ddl}.  Likewise, if the data have not been
processed, then \code{ddl} should be NULL.  This dual calling structure
allows either a single call approach for each model or alternatively the preferred method
where the data area processed and the design data (\code{ddl}) created once and
then a whole series of models can be analyzed without repeating those steps.

There are some optional arguments that can be used to set initial values and
control other aspects of the optimization.  The optimization is done with
the R package/function \code{optimx} and the arguments \code{method} and
\code{hessian} are described with the help for that function.  

In the current implementation, a logit link is used to constrain the
parameters in the unit interval (0,1) except for probability of entry which
uses an mlogit and N which uses a log link. For the probitCJS model, a probit link is
used for the parameters. These could be generalized to
use other link functions. Following the notation of MARK, the parameters in
the link space are referred to as \code{beta} and those in the actual
parameter space of \code{Phi} and \code{p} as reals.

Initial values can be set in 2 ways.  1) Define a list of named vectors with 
the initial beta parameter values (eg logit link) in \code{initial}. 
The names of the vectors should be the parameter names in the model. Any unspecified
values are set to 0. 2) Specify a previously run model for initial. The code will match the names of the
current design matrix to the names in \code{beta} and use the appropriate
initial values. Any non-specified values are set to 0.  If no value is specified for initial,
all beta are started at a value of 0.

If you have a study with unequal time intervals between capture occasions,
then these can be specified with the argument \code{time.intervals}.

The argument \code{accumulate} defaults to \code{TRUE}.  When it is
\code{TRUE} it will accumulate common capture histories that also have
common design and common fixed values (see below) for the parameters.  This
will speed up the analysis because in the calculation of the likelihood
it loops over the unique values. In general the
default will be the best unless you have many capture histories and are
using many individual covariate(s) in the formula that would make each entry
unique. In that case there will be no effect of accumulation but the code
will still try to accumulate. In that particular case by setting
\code{accumulate=FALSE} you can skip the code run for accumulation.

Most of the arguments controlling the fitted model are contained in lists in
the arguments \code{model.parameters} and \code{design.parameters} which are
similar to their counterparts in \code{mark inb RMark}. Each is a named list
with the names being the parameters in the model (e.g., Phi and p in "cjs"
and "Phi","p","pent","N" in "js"). Each named element is also a list
containing various values defining the design data and model for the
parameter. The elements of \code{model.parameters} can include
\code{formula} which is an R formula to create the design matrix for the
parameter and \code{fixed} is a matrix of fixed values as described below.
The elements of \code{design.parameters} can include \code{time.varying},
\code{fields}, \code{time.bins},\code{age.bins}, and \code{cohort.bins}. See
\code{\link{create.dmdf}} for a description of the first 2 and
\code{\link{create.dm}} for a description of the last 3.

Real parameters can be set to fixed values by specifying values for a field called fix in the design data for a parameter.
If the value of fix is NA the parameter is estimated and if it is not NA then the real
parameter is fixed at that value.  If you also specify fixed as decribed above, they will over-ride any
values you have also set with fix in the design data. To set all of the real values for a
particular occasion you can use the following example with the dipper data
as a template:

\code{model.parameters=list(Phi=list(formula=~1,}
\code{fixed=cbind(1:nrow(dipper),rep(2,nrow(dipper)),rep(1,nrow(dipper)))))}

The above sets \code{Phi} to 1 for the interval between occasions 2 and 3
for all animals.

Alternatively, you could do as follows:

data(dipper)
dp=process.data(dipper)
ddl=make.design.data(dp)
ddl$Phi$fix=ifelse(ddl$Phi$time==2,1,NA)

At present there is no modification of the parameter count
to address fixing of real parameters except that if by fixing reals, a beta is not needed in the design it will be dropped.
For example, if you were to use ~time for Phi with survival fixed to 1 for time 2, then then beta for that time would not
be included.
}
\seealso{
\code{\link{make.design.data}},\code{\link{process.data}}
}
\author{
Jeff Laake
}
\keyword{models}
